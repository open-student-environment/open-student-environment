""" Simulation environment """

from collections import defaultdict
from pymc import MCMC
import datetime

from ose.agent import Role


class Environment(object):

    def __init__(self, agents=[], statements=[]):
        """
        A Class for modeling the environment.

        Parameters
        ----------

        agents: list[Agents]
            A list of agents

        statements: list[Statement]
            A list of statements in xAPI format

        structure: dict[str: list[str]]

        """
        self._agents = {}
        self._statements = defaultdict(list)

        self.statements = statements
        self.agents = agents
        self.nodes, self.structure = self._get_structure(agents)

    @property
    def agents(self):
        return [a for a in self._agents.values()]

    @agents.setter
    def agents(self, agents):
        for a in agents:
            self.add_agent(a)

    @property
    def students(self):
        return [s for s in self.agents if s.role == Role.STUDENT]

    @property
    def teachers(self):
        return [t for t in self.agents if t.role == Role.TEACHER]

    @property
    def statements(self):
        return [s for l in self._statements.values() for s in l]

    @statements.setter
    def statements(self, statements):
        for s in statements:
            self.add_statement(s)

    @property
    def groups(self):
        groups = {}
        for agent in self.agents:
            for group in agent.groups:
                groups[group['id']] = group
        return groups

    def add_agent(self, agent):
        agent.env = self
        self._agents[agent.name] = agent
        statements = self._statements[agent.name]
        if statements:
            self._agents[agent.name].update(statements)

    def add_statement(self, statement):
        agent_name = statement['actor']
        statements = self._statements[agent_name]
        statements.append(statement)
        if agent_name in self._agents.keys():
            self.students[agent_name].update(statements)

    def simulate(self, tmax, verbose=False):
        """
        Simulate the interaction of students with resources.
        Parameters
        ----------
        tmax: float
            End time for the simulation.

        Returns
        -------
        res: list[Statements]
            List of statements generated by students.
        """
        res = []
        tmin = 0
        while tmin < tmax:
            tmin = tmax
            for s in self.students:
                statement = s.study()
                t = statement['timestamp']
                tmin = min(t, tmin)
                if t < tmax:
                    res.append(statement)
                    if verbose:
                        print("statement: {}".format(statement))
        return res

    def fit(self, params, method='mcmc', **kwargs):
        """
        Fit the model parameters to the
        Parameters
        ----------
        parames: list[parameters]
            The model parameters variable.
        method: {'mcmc'}
            The sampling strategy.
        Returns
        -------
        sampler: PYMC sampler
            Returns the parameters for each model, prefixed by `lambda_`
        """
        method_dict = {'mcmc': MCMC}
        assert method.lower() in method_dict.keys()
        params.extend([s.params for s in self.students])
        sampler = method_dict[method.lower()](params)
        sampler.sample(iter=10000, burn=1000, thin=10, )
        return sampler

    def _get_structure(self, agents):
        """
        Extracts adjancy information from the list of agents

        Arguments
        ---------
        data: list[Agents]
            Agents datastructure

        Return
        ------
        agents: dict [str -> str]

        adjancy: dict [str -> list[str]]
        """
        nodes = {}
        adjancy = defaultdict(set)
        for agent in agents:
            username = agent.name
            role = agent.role
            nodes[username] = role
            if role == Role.STUDENT:
                for g in agent.groups:
                    if g['type'] != 'school':
                        adjancy[g['id']].add(username)
                        nodes[g['id']] = g['type']
            if role == Role.TEACHER:
                for g in agent.groups:
                    if g['type'] == 'school':
                        adjancy[g['id']].add(username)
                        nodes[g['id']] = g['type']
                    else:
                        adjancy[username].add(g['id'])
                        nodes[g['id']] = g['type']
        self.structure = adjancy
        self.nodes = nodes
        return nodes, adjancy

    def _get_students(self, node, keep_inactive):
        nodes, structure = self.nodes, self.structure
        if not keep_inactive:
            active_agents = get_active_agents(self.statements)
            nodes, structure = filter_by_users(nodes, structure, active_agents)
        role = nodes[node]
        if role == Role.STUDENT:
            return set([node])
        students = set()
        for child in structure[node]:
            students = students.union(self._get_students(child, keep_inactive))
        return students

    def plot_group_activity(self, node, keep_inactive=True):
        import matplotlib.pyplot as plt
        students = self._get_students(node, keep_inactive)
        _, axes = plt.subplots(
            len(students),
            1,
            sharex='col',
            sharey='row',
            figsize=(15, len(students))
        )
        for i, student in enumerate(students):
            timestamps = []
            for s in self._statements[student]:
                timestamp = datetime.datetime.fromtimestamp(s['timestamp'])
                timestamps.append(timestamp)
            y = [1] * len(timestamps)
            axes[i].stem(timestamps, y)
        plt.show()

    def to_gdf(self, filename='test.gdf'):
        """
        Formats the adjancy list to `.gdf` (Gephi file)
        """
        nodes, adjancy = self.nodes, self.structure
        with open(filename, 'w') as f:
            f.write('nodedef> name VARCHAR, role VARCHAR\n')
            for name, role in nodes.items():
                f.write("{}, {}\n".format(name, role))
            f.write('edgedef> node1 VARCHAR, node2 VARCHAR, weight DOUBLE\n')
            for parent, children in list(adjancy.items()):
                for child in children:
                    weight = 1 if nodes[parent] == 'group' else 3
                    f.write("{}, {}, {}\n".format(parent, child, weight))


def get_active_agents(statements):
    """
    Takes a list of statements and returns a reference users list.

    Arguments
    ---------
    nodes: list[statements]
        List of statements

    Returns
    -------
    users_list: list[str]
        List of users
    """
    return {s['actor'] for s in statements}


def contains_active_student(node_name, adjancy, roles, keep):
    """
    Finds if there is a student in the children of `node_name`

    Arguments
    ---------
    node_name: str
        Name of the current node

    adjancy: dict(str: [str])
        Adjancy list of agents

    roles: dict(str: str)
        Role of the agents

    Return
    ------
    True or False
    """
    if node_name in keep:
        return True
    for child_name in adjancy[node_name]:
        if contains_active_student(child_name, adjancy, roles, keep):
            return True
    return False


def filter_by_users(nodes, adjancy, active_agents):
    """
    Takes a list of nodes, an adjancy list. Remove the non referenced
    users from the passed user reference list.

    Arguments
    ---------
    nodes: set[str]
        List of agent's names.

    adjancy: dict(str: [Agents])
        Adjancy lists indexed by agent name (agent_names -> agents).

    user_reference: set[str]
        The reference set of users.

    Returns
    -------
    nodes_clean:
        The filtered nodes set.

    nodes_clean:
        The filtered adjancy list.
    """
    nodes_keep = set()
    for name, role in nodes.items():
        if name in active_agents and role == 'user:eleve':
            nodes_keep.add(name)

    for node_name in dict(adjancy).keys():
        if contains_active_student(node_name, adjancy, nodes, nodes_keep):
            nodes_keep.add(node_name)

    nodes_clean = {k: v for k, v in nodes.items() if k in nodes_keep}
    adjancy_clean = {k: v.intersection(nodes_keep) for k, v in adjancy.items()
                     if k in nodes_keep}
    # TODO: Could be interesting to keep the inactive users for plotting.

    return nodes_clean, adjancy_clean
