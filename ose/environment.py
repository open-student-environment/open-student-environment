""" Simulation environment """

import json
from collections import defaultdict
from pymc import MCMC
import datetime
from ose.utils import filter_by_users, get_active_agents


class Environment(object):

    def __init__(self, agents=[], statements=[], nodes=None, structure=None):
        """
        A Class for modeling the environment.

        Parameters
        ----------

        agents: list[Student]
            A list of students

        statements: list[Statement]
            A list of statements in xAPI format

        structure: dict[str: list[str]]

        """
        self.students = dict()
        self._statements = defaultdict(list)

        for s in statements:
            self.add_statement(s)
        for s in agents:
            self.add_student(s)
        if nodes is not None:
            self.nodes = nodes
        if structure is not None:
            self.structure = structure

    def add_student(self, student):
        student.env = self
        self.students[student.name] = student
        statements = self._statements[student.name]
        if statements:
            self.students[student.name].update(statements)

    @property
    def statements(self):
        return [e for l in self._statements.values() for e in l]

    @property
    def groups(self):
        groups = {}
        for agent in self.students.values():
            for group in agent.groups:
                groups[group['id']] = group
        return groups

    def add_statement(self, statement):
        student_name = statement['actor']
        statements = self._statements[student_name]
        statements.append(statement)
        if student_name in self.students.keys():
            self.students[student_name].update(statements)

    def simulate(self, tmax, verbose=False):
        """
        Simulate the interaction of students with resources.
        Parameters
        ----------
        tmax: float
            End time for the simulation.

        Returns
        -------
        res: list[Statements]
            List of statements generated by students.
        """
        res = []
        tmin = 0
        while tmin < tmax:
            tmin = tmax
            for s in self.students.values():
                statement = s.study()
                t = statement['timestamp']
                tmin = min(t, tmin)
                if t < tmax:
                    res.append(statement)
                    if verbose:
                        print("statement: {}".format(statement))
        return res

    def fit(self, params, method='mcmc', **kwargs):
        """
        Fit the model parameters to the
        Parameters
        ----------
        parames: list[parameters]
            The model parameters variable.
        method: {'mcmc'}
            The sampling strategy.
        Returns
        -------
        sampler: PYMC sampler
            Returns the parameters for each model, prefixed by `lambda_`
        """
        method_dict = {'mcmc': MCMC}
        assert method.lower() in method_dict.keys()
        params.extend([s.params for s in self.students.values()])
        sampler = method_dict[method.lower()](params)
        sampler.sample(iter=10000, burn=1000, thin=10)
        return sampler

    def _get_structure(self, agents):
        """
        Extracts adjancy information from the list of agents

        Arguments
        ---------
        data: list[Agents]
            Agents datastructure

        Return
        ------
        agents: dict [str -> str]

        adjancy: dict [str -> list[str]]
        """
        nodes = {}
        adjancy = defaultdict(set)
        for agent in agents:
            username = agent.name
            role = agent.role
            nodes[username] = role
            if role == 'user:eleve':
                for g in agent.groups:
                    adjancy[g['id']].add(username)
                    nodes[g['id']] = g['type']
            if role == 'user:enseignant':
                for g in agent.groups:
                    adjancy[username].add(g['id'])
                    nodes[g['id']] = g['type']
        self.structure = adjancy
        self.nodes = nodes
        return nodes, adjancy

    def _get_students(self, node, discard_inactive):
        nodes, structure = self.node, self.structure
        if discard_inactive:
            active_agents = get_active_agents(self.statements)
            nodes, structure = filter_by_users(nodes, structure, active_agents)
        role = nodes[node]
        if role == 'user:eleve':
            return set([node])
        students = set()
        for child in self.structure[node]:
            students = students.union(self._get_students(child))
        return students

    def plot_group_activity(self, node, discard_inactive=True):
        import matplotlib.pyplot as plt
        students = self._get_students(node, discard_inactive)
        print("STUDENTS : {}".format(students))
        _, axes = plt.subplots(len(students), 1, sharex='col', sharey='row',
                               figsize=(15, len(students)))
        for i, student in enumerate(students):
            timestamps = [datetime.datetime.fromtimestamp(s['timestamp']) for s
                          in self._statements[student]]
            y = [1] * len(timestamps)
            axes[i].stem(timestamps, y)
        plt.savefig(node +".png")
